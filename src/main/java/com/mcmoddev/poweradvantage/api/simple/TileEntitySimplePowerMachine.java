package cyano.poweradvantage.api.simple;

import cyano.poweradvantage.api.ConduitType;
import cyano.poweradvantage.api.PowerConnectorContext;
import cyano.poweradvantage.api.PowerRequest;
import cyano.poweradvantage.api.PoweredEntity;
import cyano.poweradvantage.conduitnetwork.ConduitRegistry;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.inventory.ISidedInventory;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.network.NetworkManager;
import net.minecraft.network.play.server.SPacketUpdateTileEntity;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.text.ITextComponent;
import net.minecraft.util.text.TextComponentString;
import net.minecraft.util.text.TextComponentTranslation;

import java.util.Arrays;

/**
 * This block implements the cyano.poweradvantage.api.PowerSourceEntity 
 * class and handles most of the mundane details for you. You just need to 
 * implement your machine logic in the <b>tickUpdate()</b> method and provide a 
 * few methods for inventory handling. So long as you use 
 * <code>this.addEnergy(...)</code> to generate your energy, the power 
 * transmission will be handled for you automatically.<br>
 * <b>Remember to override the readFromNBT(...) and writeToNBT(...) methods</b>	 
 * @author DrCyano
 *
 */
public abstract class TileEntitySimplePowerMachine extends PoweredEntity implements ISidedInventory{
	private final ConduitType[] types;
	private final float[] energyBufferSizes;
	private final float[] energyBuffers;
	
	private String customName = null;
	
	private final String unlocalizedName;

	
	/**
	 * Constructor for TileEntitySimplePowerMachine.
	 * @param type The type of power used by this machine
	 * @param energyBufferSize The amount of energy that this machine can store 
	 * internally. Should probably be enough to hold the amount of energy 
	 * generated by a single piece of standard fuel.
	 * @param unlocalizedName The string used for language look-up and 
	 * entity registration. 
	 */
	public TileEntitySimplePowerMachine(ConduitType type, float energyBufferSize, String unlocalizedName){
		this.types = new ConduitType[1];
		this.types[0] = type;
		this.energyBufferSizes = new float[1];
		this.energyBuffers = new float[1];
		this.energyBufferSizes[0] = energyBufferSize;
		this.energyBuffers[0] = 0;
		this.unlocalizedName = unlocalizedName;
	}
	/**
	 * Constructor for TileEntitySimplePowerMachine.
	 * @param typeList The types of power used by this machine
	 * @param energyBufferSize The amount of energy that this machine can store
	 * internally for each type of energy. Should probably be enough to hold the amount of energy
	 * generated by a single piece of standard fuel.
	 * @param unlocalizedName The string used for language look-up and
	 * entity registration.
	 */
	public TileEntitySimplePowerMachine(ConduitType[] typeList, float[] energyBufferSize, String unlocalizedName){
		if(typeList.length != energyBufferSize.length) throw new IllegalArgumentException("Array length mismatch. Number of ConduitTypes and number of buffer sizes must be equal.");
		this.types = Arrays.copyOf(typeList,typeList.length);
		this.energyBufferSizes = Arrays.copyOf(energyBufferSize,energyBufferSize.length);
		this.energyBuffers = new float[this.energyBufferSizes.length];
		this.unlocalizedName = unlocalizedName;
	}
	
	/**
	 * Gets the unlocalized String passed to the constructor
	 * @return A String used in name localization by client GUI 
	 */
	public String getUnlocalizedName(){
		return unlocalizedName;
	}


	/**
	 * Gets the amount of energy that can be stored in this machine.
	 *
	 * @param energyType The type of energy being polled
	 * @return Size of the energy buffer
	 */
	@Override
	public float getEnergyCapacity(ConduitType energyType) {
		ConduitType[] types = getTypes();
		for(int i = 0; i < types.length; i++){
			ConduitType t = types[i];
			if(ConduitType.areSameType(t,energyType)){
				return energyBufferSizes[i];
			}
		}
		return 0;
	}

	/**
	 * Gets the amount of energy stored in this machine
	 *
	 * @param energyType The type of energy being polled
	 * @return The amount of energy in the energy buffer
	 */
	@Override
	public float getEnergy(ConduitType energyType) {
		ConduitType[] types = getTypes();
		int limit = Math.min(types.length, energyBuffers.length);
		for(int i = 0; i < limit; i++){
			ConduitType t = types[i];
			if(ConduitType.areSameType(t,energyType)){
				return energyBuffers[i];
			}
		}
		return 0;
	}

	/**
	 * Gets the inventory for this machine. If this machine does not have an 
	 * inventory, return null; 
	 * @return This block's inventory as an array, or null
	 */
	protected abstract ItemStack[] getInventory();
	
	/**
	 * Gets the integer array used to pass synchronization data from the server 
	 * to the clients.
	 * <p>
	 * Data fields are used for server-client synchronization of specific 
	 * variables. When this TileEntity is marked for synchronization, the 
	 * server executes the <code>prepareDataFieldsForSync()</code> method and 
	 * then transmits the contents of the array returned by 
	 * <code>getDataFieldArray()</code> to the clients in an update packet. When 
	 * the client receives this packet, it sets the values in the array from 
	 * <code>getDataFieldArray()</code> (not executed on the client-side) and 
	 * then executes the <code>onDataFieldUpdate()</code> method.
	 * </p><p>
	 * For this to work, you should store values that you want sync'd in an int 
	 * array in the <code>prepareDataFieldsForSync()</code> method and read them 
	 * back in the <code> onDataFieldUpdate()</code> method.
	 * </p>
	 * @return An int[] that you update to match local variables when 
	 * <code>prepareDataFieldsForSync()</code> is called and read from to update 
	 * local variables when <code>onDataFieldUpdate()</code> is called.
	 */
	public abstract int[] getDataFieldArray();
	
	

	/**
	 * This method is invoked before sending an update packet to the server. 
	 * After this method returns, the array returned by 
	 * <code>getDataFieldArray()</code> should hold the updated variable values.
	 * <p>
	 * Data fields are used for server-client synchronization of specific 
	 * variables. When this TileEntity is marked for synchronization, the 
	 * server executes the <code>prepareDataFieldsForSync()</code> method and 
	 * then transmits the contents of the array returned by 
	 * <code>getDataFieldArray()</code> to the clients in an update packet. When 
	 * the client receives this packet, it sets the values in the array from 
	 * <code>getDataFieldArray()</code> (not executed on the client-side) and 
	 * then executes the <code>onDataFieldUpdate()</code> method.
	 * </p><p>
	 * For this to work, you should store values that you want sync'd in an int 
	 * array in the <code>prepareDataFieldsForSync()</code> method and read them 
	 * back in the <code> onDataFieldUpdate()</code> method.
	 * </p>
	 */
	public abstract void prepareDataFieldsForSync();
	/**
	 * This method is invoked after receiving an update packet from the server. 
	 * At the time that this method is invoked, the array returned by 
	 * <code>getDataFieldArray()</code> now holds the updated variable values.
	 * <p>
	 * Data fields are used for server-client synchronization of specific 
	 * variables. When this TileEntity is marked for synchronization, the 
	 * server executes the <code>prepareDataFieldsForSync()</code> method and 
	 * then transmits the contents of the array returned by 
	 * <code>getDataFieldArray()</code> to the clients in an update packet. When 
	 * the client receives this packet, it sets the values in the array from 
	 * <code>getDataFieldArray()</code> (not executed on the client-side) and 
	 * then executes the <code> onDataFieldUpdate()</code> method.
	 * </p><p>
	 * For this to work, you should store values that you want sync'd in an int 
	 * array in the <code>prepareDataFieldsForSync()</code> method and read them 
	 * back in the <code> onDataFieldUpdate()</code> method.
	 * </p>
	 */
	public abstract void onDataFieldUpdate();
	
	
	/**
	 * This method is called once every world tick. Implement your machine logic 
	 * here, but make sure that you don't do any processing that will consume 
	 * large amounts of computer CPU time. If you do have a comuptationally 
	 * intensive calculation, break it into smaller computations that you can 
	 * spread over multiple tick updates.
	 */
	@Override
	public abstract void tickUpdate(boolean isServerWorld);
	
	
	/**
	 * This method is called when the power transmission is computed (not every 
	 * tick). You do not need to override this method, but if you do, be sure to 
	 * start with <code>super.powerUpdate()</code>
	 */
	@Override
	public void powerUpdate() {
		ConduitType[] types = this.getTypes();
		for(int i = 0; i < types.length; i++) {
			ConduitType type = types[i];
			if(this.isPowerSource(type)) {
				float availableEnergy = this.getEnergy(type);
				if(availableEnergy > 0)
					this.subtractEnergy(this.transmitPowerToConsumers(availableEnergy, type, getMinimumSinkPriority()), type);
			}
		}
	}



	/**
	 * Specifies the minimum priority of power sinks whose requests for power will be filled. Power 
	 * storage tile entities should override this method and return. Not used if <code>isPowerSource()</code> returns false
	 * <code>PowerRequest.BACKUP_PRIORITY+1</code> to avoid needlessly transferring power between 
	 * storage devices.
	 * @return The lowest priority of power request that will be filled.
	 */
	protected byte getMinimumSinkPriority(){
		return PowerRequest.BACKUP_PRIORITY;
	}
	/**
	 * Sends the provided energy out to all connected machines requesting energy.
	 * @param availableEnergy Amount of energy to send out (max)
	 * @param powerType Type of energy being sent
	 * @param minimumPriority The lowest priority of power request that will be filled.
	 * @return The amount of energy that was consumed by the requests
	 */
	protected float transmitPowerToConsumers(final float availableEnergy, ConduitType powerType, byte minimumPriority){
		return ConduitRegistry.transmitPowerToConsumers(Math.min(getMaximumPowerFlux(),availableEnergy),powerType,minimumPriority,this);
	}

	/**
	 * Override this method to limit the flow of power to or from this machine. By default, power flow is practically
	 * infinite.
	 * @return The maximum amount of energy that can flow from or to this machine per power update (per 8 game ticks).
	 */
	public float getMaximumPowerFlux(){
		return 1000000;
	}

	/**
	 * Specify how much energy this power sink wants from a power generator. If this tile entity is 
	 * not a sink, then simply return PowerRequest.REQUEST_NOTHING
	 * @param type The type of energy available upon request
	 * @return A PowerRequest instance indicated how much power you'd like to get
	 */
	public PowerRequest getPowerRequest(ConduitType type){
		if(this.isPowerSink(type)){
			ConduitType[] types = this.getTypes();
			for(int i = 0; i < types.length; i++){
				if(ConduitType.areSameType(types[i],type)
						&& this.getEnergyCapacity(type) > this.getEnergy(type)){
					return new PowerRequest(
							(this.isPowerSource(type) ? this.getMinimumSinkPriority() - 1 : PowerRequest.MEDIUM_PRIORITY),
							Math.min(getMaximumPowerFlux(),this.getEnergyCapacity(type) - this.getEnergy(type)),
							this);
				}
			}
		}
		return PowerRequest.REQUEST_NOTHING;
	}
	
	/**
	 * You must override this method and call super.readFromNBT(...).<br><br>
	 * This method reads data from an NBT data tag (either from a data packet 
	 * or loaded from the Chunk).
	 * @param tagRoot The root of the NBT
	 */
	@Override
	public void readFromNBT(final NBTTagCompound tagRoot) {
		super.readFromNBT(tagRoot);
		ItemStack[] inventory = this.getInventory();
		if(inventory != null ){
			final NBTTagList nbttaglist = tagRoot.getTagList("Items", 10);
			for (int i = 0; i < nbttaglist.tagCount() && i < inventory.length; ++i) {
				final NBTTagCompound nbttagcompound1 = nbttaglist.getCompoundTagAt(i);
				final byte n = nbttagcompound1.getByte("Slot");
				if (n >= 0 && n < inventory.length) {
					inventory[n] = new ItemStack(nbttagcompound1);
				}
			}
		}
		if (tagRoot.hasKey("CustomName", 8)) {
			this.customName = tagRoot.getString("CustomName");
		}
	}
	
	/**
	 * You must override this method and call super.writeToNBT(...).<br><br>
	 * This method writes data to an NBT data tag (either to a data packet 
	 * or saved to the Chunk).
	 * @param tagRoot The root of the NBT
	 */
	@Override
	public NBTTagCompound writeToNBT(final NBTTagCompound tagRoot) {
		super.writeToNBT(tagRoot);
		ItemStack[] inventory = this.getInventory();
		if(inventory != null ){
			final NBTTagList nbttaglist = new NBTTagList();
			for (int i = 0; i < inventory.length; ++i) {
				if (inventory[i] != null) {
					final NBTTagCompound nbttagcompound1 = new NBTTagCompound();
					nbttagcompound1.setByte("Slot", (byte)i);
					inventory[i].writeToNBT(nbttagcompound1);
					nbttaglist.appendTag(nbttagcompound1);
				}
			}
			tagRoot.setTag("Items", nbttaglist);
		}
		if (this.hasCustomName()) {
			tagRoot.setString("CustomName", this.customName);
		}
		return tagRoot;
	}
	

	/**
	 * Gets the energy type for this block.
	 * @return The type of energy/power for this block
	 */
	@Override
	public ConduitType[] getTypes() {
		return types;
	}

	/**
	 * Determines whether this conduit is compatible with an adjacent one
	 * @param connection A context object that provides the power type and block direction information
	 * @return True if power should be allowed to flow through this connection, false otherwise
	 */
	@Override
	public boolean canAcceptConnection(PowerConnectorContext connection){
		ConduitType[] myTypes = getTypes();
		for(int i = 0; i < myTypes.length; i++){
			if(ConduitType.areSameType(myTypes[i],connection.powerType)) return true;
		}
		return false;
	}



	/**
	 * Sets the amount of energy stored in this block
	 * @param energy New value of the energy buffer
	 */
	@Override
	public void setEnergy(float energy,ConduitType type) {
		ConduitType[] types = getTypes();
		for(int i = 0; i < types.length; i++){
			ConduitType t = types[i];
			if(ConduitType.areSameType(t,type)){
				energyBuffers[i] = energy;
			}
		}
	}
	

	
	

	/**
	 * This method is called when a block is renamed (e.g. with an anvil) and 
	 * then placed into the world.
	 * @param newName The custom name of the block
	 */
	public void setCustomInventoryName(final String newName) {
		this.customName = newName;
	}
	
	

 /// SYNCHRONIZATION OF DATA FIELDS
	/**
	 * Creates a NBT to send a synchronization update using this block's data 
	 * field array (see <code>getDataFieldArray()</code>). Before this method 
	 * executes, it calls <code>prepareDataFieldsForSync()</code>.
	 * @return A synchronization NBT holding values from the 
	 * <code>getDataFieldArray()</code> array
	 */
	public NBTTagCompound createDataFieldUpdateTag(){
		this.prepareDataFieldsForSync();
		int[] dataFields = this.getDataFieldArray();
		NBTTagCompound nbtTag = new NBTTagCompound();
		nbtTag.setIntArray("[]", dataFields);
		return nbtTag;
	}

	/**
	 * Reads a synchronization update NBT and stores it in this blocks data 
	 * field array (see <code>getDataFieldArray()</code>). After this method 
	 * executes, it calls <code>onDataFieldUpdate()</code>.
	 * @param tag A synchronization NBT holding values from the 
	 * <code>getDataFieldArray()</code> array
	 */
	public void readDataFieldUpdateTag(NBTTagCompound tag){
		int[] newData = tag.getIntArray("[]");
		System.arraycopy(newData, 0, this.getDataFieldArray(), 0, Math.min(newData.length, this.getDataFieldArray().length));
		this.onDataFieldUpdate();
	}
	
	
	/**
	 * Turns the data field NBT into a network packet
	 */
	@Override 
	public SPacketUpdateTileEntity getUpdatePacket(){
		NBTTagCompound nbtTag = createDataFieldUpdateTag();
		return new SPacketUpdateTileEntity(this.pos, 0, nbtTag);
	}

	/**
	 * Receives the network packet made by <code>getDescriptionPacket()</code>
	 */
	@Override
	public void onDataPacket(NetworkManager net, SPacketUpdateTileEntity packet) {
		readDataFieldUpdateTag(packet.getNbtCompound());
	}
	
///// ISidedInventory methods /////
	/**
	 * Removes all items from this machine's inventory.
	 */
	@Override
	public void clear() {
		if(this.getInventory() == null) return;
		for(int i = 0; i < this.getInventory().length; i++){
			this.getInventory()[i] = null;
		}
		
	}

	
	/**
	 * executes when a player right-clicks and opens the inventory GUI
	 */
	@Override
	public void openInventory(EntityPlayer arg0) {
		// do nothing
		
	}
	
	/**
	 * executes when a player stops interacting with this machine 
	 */
	@Override
	public void closeInventory(EntityPlayer arg0) {
		// do nothing
		
	}

	/**
	 * boilerplate inventory code
	 */
	@Override
	public ItemStack decrStackSize(int slot, int decrement) {
		if (this.getInventory()[slot] == null) {
			return null;
		}
		if (this.getInventory()[slot].getCount() <= decrement) {
			final ItemStack itemstack = this.getInventory()[slot];
			this.getInventory()[slot] = null;
			return itemstack;
		}
		final ItemStack itemstack = this.getInventory()[slot].splitStack(decrement);
		if (this.getInventory()[slot].getCount() == 0) {
			this.getInventory()[slot] = null;
		}
		return itemstack;
	}

	
	/**
	 * gets a field from the data array
	 */
	@Override
	public int getField(final int fieldIndex) {
		if(this.getDataFieldArray() != null){
			return this.getDataFieldArray()[fieldIndex];
		} else {
			return 0;
		}
	}
	
	/**
	 * sets a field in the data array
	 */
	@Override
	public void setField(final int fieldIndex, final int fieldValue) {
		if(this.getDataFieldArray() != null){
			this.getDataFieldArray()[fieldIndex] = fieldValue;
		} else {
			// do nothing
		}
	}
	
	/**
	 * Gets the number of data fields
	 * @return The size of the data array
	 */
	@Override
	public int getFieldCount() {
		if(this.getDataFieldArray() != null){
			return this.getDataFieldArray().length;
		} else {
			return 0;
		}
	}
	

	/**
	 * boilerplate inventory code
	 */
	@Override
	public int getInventoryStackLimit() {
		return 64;
	}

	/**
	 * boilerplate inventory code
	 * @return The size of this machine's inventory (returns 0 if there is no 
	 * inventory)
	 */
	@Override
	public int getSizeInventory() {
		if(this.getInventory() != null){
			return this.getInventory().length;
		} else {
			return 0;
		}
	}

	/**
	 * boilerplate inventory code
	 * @param slot inventory slot index
	 * @return Item in a given inventory slot (null means no item)
	 */
	@Override
	public ItemStack getStackInSlot(int slot) {
		if(this.getInventory() != null){
			return this.getInventory()[slot];
		} else {
			return null;
		}
	}
	
	/**
	 * boilerplate inventory code
	 * @param slot inventory slot index
	 * @return Item in a given inventory slot (null means no item)
	 */
	@Override
	public ItemStack removeStackFromSlot(int slot) {
		if(this.getInventory() != null){
			ItemStack i = this.getInventory()[slot];
			this.getInventory()[slot] = null;
			return i;
		} else {
			return null;
		}
	}
	
	

	/**
	 * Determines whether a given item is allowed to be added to a given 
	 * inventory slot.
	 * @param slot Index in the inventory where Minecraft is trying to put the 
	 * item 
	 * @param item The item in question 
	 * @return true if the item is allowed to go in the indicated slot, false 
	 * otherwise 
	 */
	@Override
	public boolean isItemValidForSlot(final int slot, final ItemStack item) {
		if(this.getInventory() == null) return false;
		return slot < this.getInventory().length; 
	}

	/**
	 * boilerplate inventory code
	 */
	@Override
	public boolean isUsableByPlayer(final EntityPlayer p_isUseableByPlayer_1_) {
		return this.world.getTileEntity(this.pos) == this && p_isUseableByPlayer_1_.getDistanceSq((double)this.pos.getX() + 0.5, (double)this.pos.getY() + 0.5, (double)this.pos.getZ() + 0.5) <= 64.0;
	}

	/**
	 * boilerplate inventory code
	 */
	@Override
	public void setInventorySlotContents(int slot, ItemStack item) {
		if(this.getInventory() == null) return;
		final boolean flag = item != null && item.isItemEqual(this.getInventory()[slot]) 
				&& ItemStack.areItemStackTagsEqual(item, this.getInventory()[slot]);
		this.getInventory()[slot] = item;
		if (item != null && item.getCount() > this.getInventoryStackLimit()) {
			item.setCount(this.getInventoryStackLimit());
		}
		if (slot == 0 && !flag) {
			this.markDirty();
		}
	}
	

	/**
	 * boilerplate inventory code
	 */
	@Override
	public ITextComponent getDisplayName() {
		if (this.hasCustomName()) {
			return new TextComponentString(this.getName());
		}
		return new TextComponentTranslation(this.getName(), new Object[0]);
	}

	/**
	 * boilerplate inventory code
	 * @return either the unlocalized name for this entity or a custom name 
	 * given by the player (i.e. with an anvil)
	 */
	@Override
	public String getName() {
		return this.hasCustomName() ? this.customName : unlocalizedName;
	}

	/**
	 * boilerplate inventory code
	 * @return true if this block has been renamed, false otherwise
	 */
	@Override
	public boolean hasCustomName() {
		return customName != null;
	}

	/**
	 * Determines whether another block (such as a Hopper) is allowed to pull an 
	 * item from this block out through a given face
	 * @param slot The inventory slot (index) of the item in question
	 * @param targetItem The item to be pulled
	 * @param side The side of the block through which to pull the item
	 * @return true if the item is allowed to be pulled, false otherwise
	 */
	@Override
	public boolean canExtractItem(final int slot, final ItemStack targetItem, final EnumFacing side) {
		if(this.getInventory() == null) return false;
		return slot < this.getInventory().length;
	}

	/**
	 * Determines whether another block (such as a Hopper) is allowed to put an 
	 * item into this block through a given face
	 * @param slot The inventory slot (index) of the item in question
	 * @param srcItem The item to be inserted
	 * @param side The side of the block through which to insertt the item
	 * @return true if the item is allowed to be inserted, false otherwise
	 */
	@Override
	public boolean canInsertItem(final int slot, final ItemStack srcItem, final EnumFacing side) {
		if(this.getInventory() == null) return false;
		return this.isItemValidForSlot(slot, srcItem);
	}

	/** cache for default implementation of getSlotsForFace(...)*/
	private int[] slotAccessCache = null;

	/**
	 * This method is used to tell other blocks (such as a hopper) which 
	 * inventory slots they are allowed to interact with, based on which face of 
	 * this block they are touching. Override this method to make output slots 
	 * go out the bottom of this block and input slots go in the top (like a 
	 * furnace).<br><br>
	 * The default implementation here makes all inventory slots accessible from 
	 * all sides.
	 * @param side The side of this block through which the other entity wants to 
	 * access the inventory 
	 * @return An array listing all of the inventory indices that are accessible 
	 * through the given side of this block
	 */
	@Override
	public int[] getSlotsForFace(EnumFacing side) {
		if(slotAccessCache != null) return slotAccessCache;
		if(this.getInventory() == null){
			slotAccessCache = new int[0];
		} else {
			slotAccessCache = new int[this.getInventory().length];
			for(int i = 0; i < slotAccessCache.length; i++){
				slotAccessCache[i] = i;
			}
		}
		return slotAccessCache;
	}
}